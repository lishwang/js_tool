##### 笔记内容可以参考 wls 的 [自定义工具函数库](https://zxfjd3g.github.io/aishangwang_utils-docs/)

##### 本仓库一共有两个分支：dev 和 master

- dev 分支：封装的 js 方法在 js 代码中简单使用
- master 分支：通过 webpack 打包后，生成 UMD 形式的库，可以同时在 nodejs 和浏览器环境中使用，可以通过 es6、commonjs、es5 的方式引入使用；并且在该分支下，还对代码做了调整，使其可以发布到 npm 中央仓库上供所有人使用；

##### 通过 webpack 打包后，生成 UMD 形式的库

```
# webpack.config.js 文件内
// 出口
output: {
    // 向外暴露的对象的名称，打包后，引入 wls_utils.js 文件后，可以在全局直接使用 utils ，里面包含本次打包的入口文件内的导出的所有方法
    library: 'utils',
    // 打包生成umd的库，模块导入的时候可以通过esm（es6）/commonjs（common）/requirejs（amd）的语法引入该打包后的文件
    libraryTarget: 'umd',
  }
```

##### 发布到 npm 中央仓库

```
# package.json 文件内
name: 必须是唯一的名称(在npm在线中央仓库中没有同名的，小写)
main: 必须指定为打包生成的js文件路径
keywords: 指定一些方便别的程序员搜索到当前库的关键字（npm中可以直接搜到）
```

###### 发布之前需要对 npm 本地做如下配置修改

- npm 配置的中央仓库不能是淘宝镜像，因为淘宝镜像是一个只读镜像，只能下载不能上传；
- 发布前必须执行: npm config set registry https://registry.npmjs.org/
- 不用发布时再改回: npm config set registry http://registry.npm.taobao.org/
- 查看配置: npm config list

###### 注册 npm 中央仓库账号

- 注册地址: https://www.npmjs.com/
- 关键信息: 用户名/密码/邮箱(需要验证)

###### 添加用户

- 执行: npm addUser 或者 npm login
- 登陆 npm 仓库
- 依次指定用户名/密码/邮箱（密码输入的时候是不可见的）

###### 发布仓库

- 执行: npm publish
- 常见的发布失败的错误

![](C:\Users\WLS\Desktop\自己练习\前端\练习\JS\tool\image\常见的发布失败的错误.png)

- 发布失败, 原因是库的名称重复了, 修改 name 为一个唯一值, 再发布

###### 如果以后需要更新 npm 中央仓代码，需要更新代码后再发布

- 修改项目库的版本号: package.json 中的 version 从 1.0.0 改为 1.0.1, 注意一定要变大
- 修改代码后重新打包: npm run build
- 执行发布: npm publish

###### 强制删除已发布在 npm 中央仓的库

- 执行: npm unpublish --force 默认删除最近一次提交的版本
- 执行: npm unpublish 名字 --force 删除这个 npm 包
- 注意: 必须在 72 小时内, 否则不能再删除

##### 我的 npm 账号为 wls\_ 密码为 平常的密码，字母后面加名字缩写

---

---

---

# ES6

### Symbol

##### Symbol 的基本使用

- ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。
- 创建 Symbol
  - 字面量 `Symbol()` ;
  - `Symbol.for('wls')` ;

```
// 方法一：
let s1 = Symbol();
let s2 = Symbol('aaa');
console.log(s1, typeof s1);

// 方法二：
let s3 = Symbol.for('wls');
let s3_2 = Symbol.for('wls');
console.log(s3 === s3_2);
```

##### Symbol 特点

- Symbol 的值是唯一的，用来解决命名冲突的问题；
- Symbol 值不能与其他数据进行运算；
- Symbol 定义 的 对象属 性 不能 使 用 ` for…in` 循 环遍 历 ，但 是可 以 使 用 `Reflect.ownKeys` 来获取对象的所有键名;

##### **Symbol** **内置属性**

- Symbol 内置属性 是固定写法，它的整体通常作为对象的一个属性，来改变对象在特定场景下的表现，可以扩展对象的功能；

| 内置属性                  | 作用                                                                                                               |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| Symbol.hasInstance        | 当其他对象使用 instanceof 运算符，判断是否为该对象的实例时，会调用这个方法                                         |
| Symbol.isConcatSpreadable | 对象的 Symbol.isConcatSpreadable 属性等于的是一个布尔值，表示该对象用于 Array.prototype.concat()时，是否可以展开。 |
| Symbol.species            | 创建衍生对象时，会使用该属性                                                                                       |
| Symbol.match              | 当执行 str.match(myObject) 时，如果该属性存在，会调用它，返回该方法的返回值。                                      |
| Symbol.replace            | 当该对象被 str.replace(myObject)方法调用时，会返回该方法的返回值。                                                 |
| Symbol.search             | 当该对象被 str.search (myObject)方法调用时，会返回该方法的返回值。                                                 |
| Symbol.split              | 当该对象被 str.split(myObject)方法调用时，会返回该方法的返回值。                                                   |
| Symbol.iterator           | 对象进行 for...of 循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器                                      |
| Symbol.toPrimitive        | 该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。                                           |
| Symbol. toStringTag       | 在该对象上面调用 toString 方法时，返回该方法的返回值                                                               |
| Symbol. unscopables       | 该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除。                                                       |

##### 属性练习

###### Symbol.hasInstance 可以自己来控制类型检测

```
属性一：Symbol.hasInstance 可以自己来控制类型检测
class Person{
    static [Symbol.hasInstance](param){
        console.log(param); // {a: 1};
        console.log("我被用来检测类型了");
        return true;
    }
}
let o = {a: 1};
console.log(o instanceof Person); // true
```

###### Symbol.isConcatSpreadable 可以控制数组采用 concat 合并时，某个数组是否被展开后合并

```
属性二：Symbol.isConcatSpreadable 可以控制数组采用concat合并时，某个数组是否被展开后合并
const arr = [1,2,3];
const arr2 = [4,5,6];
arr2[Symbol.isConcatSpreadable] = false;
console.log(arr.concat(arr2)); // [1,2,3,[4,5,6]]
```

### iterator 迭代器

##### 迭代器简介

- 迭代器是一种接口，在 JS 中就指对象中的一个属性，这个属性的名字叫做 `Symbol.iterator` ，对应的属性值是一个函数，任何数据结构只要部署 iterator 接口，就可以完成遍历操作，就可以采用 `for...of` 遍历；
- 原生就具备 iterator 接口的数据（可以直接采用 `for...of` 遍历）
  - Array
  - Arguments
  - Set
  - Map
  - String
  - TypedArray
  - NodeList

##### 迭代器的工作原理

1. 创建一个指针对象，指向当前数据结构的起始位置（迭代器是一个函数，这个函数返回一个对象，就是这个指针对象）；
2. 第一次调用这个指针对象的 `next` 方法，指针自动指向数据结构的第一个成员，并返回第一个成员组成的对象；
3. 接下来不断调用 `next` 方法，指针一直往后移动，直到指向最后一个成员；
4. 每调用一次 `next` 方法返回一个包含 `value` 和 `done` 属性的对象；

```
/**
 * 自定义迭代器
*/
let obj = {
    name: 'wang',
    children: ['a', 'b', 'c', 'd'],
    // 自定义迭代器，给obj对象添加迭代器，使得obj对象可以用for...of遍历，且遍历的每一项项为 obj.children 的内容
    /**
     * 自定义迭代器：
     * 1、迭代器是一个函数；
     * 2、迭代器这个函数的返回值是一个对象；
     * 3、这个对象中有 next 方法；
     * 4、这个 next 方法的返回值是一个对象，这个对象中包含遍历的每一项，执行 next 方法返回这个对象: {value: 每一项, done: false}；
     * 5、每次执行 next 方法索引值加1，直到当前索引等于要遍历的内容的长度，此时执行next方法，返回一个对象: {value: undefined, done:true};
    */
    [Symbol.iterator]: function () {
        // 初始化索引
        let _index = 0;
        // 保存this指向
        let _this = this;
        // 迭代器函数返回一个对象
        return {
            // 对象中包含 next 方法
            next: function () {
                if (_index < _this.children.length) {
                    // next方法返回一个对象，这个对象中包含value遍历的元素，done是否遍历结束；
                    let result = {
                        value: _this.children[_index],
                        done: false,
                    }
                    // 索引自增，遍历下一项；
                    _index++;
                    // 返回
                    return result;
                } else {
                    // 遍历结束，执行next返回对象；
                    return {
                        value: undefined,
                        done: true,
                    }
                }
            },
        }
    },
};

// 自定义遍历对象，实例遍历对象中的children属性值
for (let v of obj) {
    console.log(v); // a b c d
}
```

### 生成器

##### 生成器简介

- 生成器是 ES6 提供的一种**异步编程解决方案**，语法行为与传统函数完全不同；生成器就是**一种特殊的函数**；

##### 生成器 与 函数 的区别：

- 生成器的写法跟函数类似，只是在 `function` 与 函数名 中间加一个 `*` ;
- 生成器函数的执行结果是一个 迭代器 对象；因此可以把 这个迭代器函数的执行 当做数组通过 `for...of` 遍历；
  - `for(let v of gen()){ }`
- 执行 生成器函数后，并不会执行生成器函数内部的代码，知道执行 生成器函数返回的迭代器对象的 next 方法后，才会执行 生成器函数内部的代码；
- 在生成器函数内部可以执行 yield 语句；yield 语句可以当做函数代码的分隔符；比如 生成器函数中有 3 条 yield 语句，就可以把生成器函数中的代码分为 4 部分；执行一次 next 函数，就只执行生成器函数的第一部分，依次类推；

```
## 生成器函数的简单使用；
function * gen(){
	console.log('hello');
}

let iterator = gen(); // 此时并没有执行 生成器函数内部的代码；并且返回 迭代器对象；
iterator.next(); // 此时才会执行 生成器函数内部的代码；


## 在生成器函数内部使用 yield 语句，把生成器函数中的代码分为多个部分；（比如 生成器函数中有 3条 yield 语句，就可以把生成器函数中的代码分为 4 部分；）
function* gen () {
    console.log(111);
    yield '一只没有耳朵';
    console.log(222);
    yield '一只没有尾部';
    console.log(333);
    yield '真奇怪';
    console.log(444);
}
let iterator = gen();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());

// 由于生成器函数的执行结果是一个迭代器对象，因此可以直接通过 for...of 来遍历生成器函数的执行结果
// for(let v of gen()) {
//     console.log(v);
// }
```

##### 生成器函数参数

- 执行生成器函数时传递参数，可以在整个生成器函数内部使用；
- 执行 next 函数时也可以传递参数，而且这个参数将作为上一个 yield 语句的返回结果；（**即：第二个 next 函数的传参作为第一个 yield 语句的返回结果**）

```
function* gen (arg) {
    console.log(arg); // AAA
    let one = yield 111;
    console.log(one); // BBB
    let two = yield 222;
    console.log(two); // CCC
    let three = yield 333;
    console.log(three); // DDD
}

//执行获取迭代器对象
let iterator = gen('AAA');
console.log(iterator.next()); // {done: false, value: 111};

//next方法可以传入实参
console.log(iterator.next('BBB')); // {done: false, value: 222};
console.log(iterator.next('CCC')); // {done: false, value: 333};
console.log(iterator.next('DDD')); // {done: true, value: undefined};
```

### Promise

- promise 的具体使用以及原码实现参考 my_promise 库；

### set

- 类似于数组，但成员的值都是唯一的，set 集合实现了 iterator 接口，所以可以使用 扩展运算符 和 `for...of` 进行遍历;

##### set 集合的属性和方法

- size 返回集合的元素个数；
- add 增加一个新元素，返回当前集合；
- delete 删除元素，返回 boolean 值；
- has 检测集合中是否包含某个元素，返回 Boolean 值；
- clear 清空集合；

### Map

- Map 类似于 对象，也是键值对的集合，但是 键名 的范围不限于字符串，而是各种类型的值（包括对象）都可以当做键名；Map 也实现了 iterator 接口，所以可以使用 扩展运算符 和 `for...of` 进行遍历;

##### Map 的属性和方法

- size 返回 Map 的元素的个数；
- set 增加一个新元素，并返回当前 Map ；
- get 返回查找键名对象的键值；
- has 检测 Map 中是否包含某个元素，返回 Boolean 值；
- clear 清空集合，返回 undefined；

### 类

- ES6 的 class 可以看做只是一个语法糖，它的绝大部分功能 ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已；ES6 中定义类可以没有构造函数 constructor；

##### 知识点:

- class 声明类
- constructor 定义构造函数初始化
- extends 继承父类
- super 调用父级构造方法
- static 定义静态方法和属性
- 父类方法可以重写

##### 类的静态成员

- 静态成员只存在于构造函数或类中，在实例对象上不可见；

###### ES5 的构造函数的静态成员

- 构造函数身上的属性和方法（非原型上的属性和方法），称为静态成员

```
// ES5 构造函数定义类
function Phone (brand, price) {
    this.brand = brand;
    this.price = price;
}
//添加方法，实例上可以看到
Phone.prototype.call = function () {
    console.log("call");
}
// 添加方法，实例上不可见（实例对象身上是没有构造函数身上的属性和方法的，称为静态成员）
Phone.use = function () {
    console.log('use')
}
//实例化对象
let Huawei = new Phone('华为', 5999);
Huawei.call(); // 'call'
Phone.use(); // 'use'
// Huawei.use(); // 报错
```

###### ES6 的 class 类的静态成员

- 用 `static` 关键字来定义静态成员；

```
// ES6 class定义类
class Shouji {
    //构造方法 名字不能修改
    constructor (brand, price) {
        this.brand = brand;
        this.price = price;
    }
    // 添加方法，实例上可以看到
    //方法必须使用该语法, 不能使用 ES5 的对象完整形
    call () {
        console.log("call");
    }
    // 添加方法，实例上不可见
    static use () {
        console.log('use');
    }
}
let onePlus = new Shouji("1+", 1999);
onePlus.call(); // 'call'
Shouji.use(); // 'use'
// onePlus.use(); // 报错
```

##### 类的继承

###### ES5 的构造函数的继承

- 子类在属性初始化时可以执行 `父类.call(this, xxx, xxx)` ，相当于执行了父级构造函数里的初始化代码，以实现**继承父类身上属性**的效果；
- 注意：
  - 需要修改子级构造函数的原型，这样子类的实例对象上面就会有父级原型上的方法和属性（**继承父类原型上的属性和方法**）；
  - （非必须）矫正子级构造函数的指向，这样子类的实例对象的构造函数的指向就是子类 SmartPhone，如果这一行代码不写，就指向父类 Phone；
- 实例化子级构造函数后
  - 父级构造函数原型上的方法和属性可以在实例的隐式原型的隐式原型上找到（` 实例对象.__proto__.__proto__` ）;
  - 子级构造函数原型上的方法和属性可以在实例的隐式原型上找到（ `实例对象.__proto__` ）;

```
// 父类
function Phone (brand, price) {
    this.brand = brand;
    this.price = price;
}
Phone.prototype.call = function () {
    console.log("我可以打电话");
}
// 子类
function SmartPhone (brand, price, color, size) {
    // 先调用父级构造函数里的初始化代码
    Phone.call(this, brand, price);
    // 子构造函数初始化
    this.color = color;
    this.size = size;
}
// 设置子级构造函数的原型，这样子类的实例对象上面就会有父级原型上的方法和属性；
SmartPhone.prototype = new Phone;
// 矫正子级构造函数的指向，这样子类的实例对象的构造函数的指向就是子类SmartPhone，如果这一行代码不写，就指向父类Phone；
SmartPhone.prototype.constructor = SmartPhone;
// 声明子类的方法
SmartPhone.prototype.photo = function () {
    console.log("我可以拍照")
}
SmartPhone.prototype.playGame = function () {
    console.log("我可以玩游戏");
}
const chuizi = new SmartPhone('锤子', 2499, '黑色', '5.5inch');
/**
 * 父级构造函数原型上的方法和属性可以在实例的隐式原型的隐式原型上找到（chuizi.__proto__.__proto__）
 * 子级构造函数原型上的方法和属性可以在实例的隐式原型上找到（chuizi.__proto__）
*/
console.log(chuizi);
```

###### ES6 的类的继承

- `class 子类 extends 父类` 即可实现子类对父类的继承；并且不需要修改子级构造函数的原型，子类的实例对象上面就会有父级原型上的方法和属性（非 static 静态的属性和方法）；并且不需要矫正子类的构造函数的指向；

- 在子类构造函数中调用 `super(xxx)` 方法相当于调用了父类的 constructor 方法，并传入了参数；

```
// 父类
class Phone {
    //构造方法（可以不写）
    constructor (brand, price) {
        this.brand = brand;
        this.price = price;
    }
    //父类的成员属性
    call () {
        console.log("我可以打电话!!");
    }
}
// 子类
class SmartPhone extends Phone {
    //构造方法
    constructor (brand, price, color, size) {
        // super(xxx); 相当于调用了父类的constructor方法，并传入了参数
        super(brand, price);// Phone.call(this, brand, price)
        this.color = color;
        this.size = size;
    }
    photo () {
        console.log("拍照");
    }
    playGame () {
        console.log("玩游戏");
    }
    // 重写父类中的call方法
    call () {
        console.log('我可以进行视频通话');
    }
}
const xiaomi = new SmartPhone('小米', 799, '黑色', '4.7inch');
console.log(xiaomi);
xiaomi.call();
xiaomi.photo();
xiaomi.playGame();
```

##### ES6 class 类中的 get 和 set 关键字

- ES6 中定义类可以没有构造函数 constructor ；
- 可以定义多个 get 和 set 关键字定义的属性；
- get 和 set 的用法如下：

```
// get 和 set
class Phone {
    // 只要读取实例对象中的 price 属性，就会执行这个方法，这个方法的返回值就是读取到的 price 属性的
    get price () {
        console.log("价格属性被读取了");
        return 'iloveyou';
    }
    get wang () {
        console.log("wang属性被读取了");
        return 'wang';
    }
    // 只要修改实例对象中的 price 属性，就会执行这个方法
    set price (newVal) {
        console.log('价格属性被修改了');
    }
}
//实例化对象
let s = new Phone();
// 读取实例中的price属性，触发类中的 get 方法；
console.log(s.price); // 'price';
console.log(s.wang); // 'wang';
// 修改实例中price属性，触发类中的 set 方法；
s.price = 'free';
```

### 数值扩展

##### Number.EPSILON

- Number.EPSILON 是 JavaScript 表示的最小精度，它的值接近于 `2.2204460492503130808472633361816E-16` ;
- 可以用于比较两个数是否相等；在 js 中，如果两个数的差值的绝对值小于 Number.EPSILON，就说明这两个数相等；

```
function equal(a, b){
    if(Math.abs(a-b) < Number.EPSILON){
        return true;
    }else{
        return false;
    }
}
console.log(0.1 + 0.2 === 0.3); // false
console.log(equal(0.1 + 0.2, 0.3)) // true
```

##### 二进制、八进制、十进制、十六进制

- 二进制以 0b 开头； ` let b = 0b1010` ;
- 八进制以 0o 开头；`let o = 0o777` ；
- 十进制；`let d = 100` ；
- 十六进制以 0x 开头；`let x = 0xff` ；

##### Number.isFinite

- Number.isFinite 检测一个数值是否为有限数，返回值为布尔值，有限数返回 true，无限数返回 false；

```
console.log(Number.isFinite(100)); // true
console.log(Number.isFinite(100/0)); // false
console.log(Number.isFinite(Infinity)); // 无穷 也是无限数
```

##### Number.isNaN

- Number.isNaN 检测一个数值是否为 NaN;

##### ES5 中 isNaN() 和 ES6 中的 Number.isNaN() 的区别？

- ES5 中 isNaN() 的判断过程：首先进行类型检测，如果传入的参数不是数值类型，就把传入的参数转换成数值类型，然后再进行是否为 NaN 的判断；存在隐式转换的过程；

  ```
  console.log(isNaN('')); // false;
  console.log(isNaN('a')); // true;
  console.log(isNaN(null)); // false;
  console.log(isNaN(true)); // false;
  console.log(isNaN(undefined)); // true;
  ```

- ES6 中 Number.isNaN() 的判断过程：首先进行类型检测，如果传入的参数不是数值类型，直接返回 false，否则再进行 isNaN() 的方式的判断；

  ```
  console.log(Number.isNaN('a')); // false;
  console.log(Number.isNaN(undefined)); // false;
  console.log(Number.isNaN(NaN)); // true;
  ```

##### Number.parseInt 和 Number.parseFloat

- Number.parseInt 字符串转整数
- Number.parseFloat 字符串转小数

```
console.log(Number.parseInt('5211314love')); // 5211314
console.log(Number.parseFloat('3.1415926神奇')); // 3.1415926
```

##### Number.isInteger

- Number.isInteger 判断一个数是否为整数，返回值为布尔值;

```
console.log(Number.isInteger(5)); // true
console.log(Number.isInteger(2.5)); // false
```

##### Math.trunc

- Math.trunc 将数字的小数部分抹掉 ;

```
console.log(Math.trunc(3.5)); // 3
console.log(Math.trunc(-3.5)); // -3
```

##### Math.sign

- Math.sign 判断一个数到底为正数 负数 还是零，正数返回 1，零返回 0，负数返回-1 ;

```
console.log(Math.sign(100)); // 1
console.log(Math.sign(0)); // 0
console.log(Math.sign(-20000)); // -1
```

### 对象方法扩展

##### Object.is()

- Object.is() 判断两个值是否完全相等，结果基本上与 === 一致，但是对于个别属性上的判断有区别，例如 NaN、+0、-0;

```
console.log(Object.is(120, 120)); // true
console.log(Object.is(NaN, NaN)); // true
console.log(NaN === NaN); // false
console.log(Object.is(+0, -0)); // false
console.log(+0 === -0); // true
```

##### Object.assign()

- Object.assign() 对象的合并，如果有相同的属性，后者覆盖前者；

```
const config1 = {
    host: 'localhost',
    test: 'test'
};
const config2 = {
    host: 'http://111.com',
    test2: 'test2'
}
console.log(Object.assign(config1, config2));
```

##### Object.setPrototypeOf 和 Object.getPrototypeof

- Object.setPrototypeOf(参数一，参数二) **设置原型对象**，将参数二设置为参数一的原型；

- Object.getPrototypeof(参数一) **获取原型对象**，获取参数一的原型；

```
const school = {
    name: 'wang'
}
const cities = {
    xiaoqu: ['北京', '上海', '深圳']
}
Object.setPrototypeOf(school, cities);
console.log(Object.getPrototypeOf(school));
console.log(school);
```



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------

# ES7

### includes

- Array.prototype.includes 方法用于检测数组中是否包含某个元素，返回布尔值；

### 指数操作符 ** 

- ** 指数操作符用来实现幂运算，功能与 ` Math.pow ` 结果相同；

```
console.log(2 ** 10); // 1024
console.log(Math.pow(2, 10)); // 1024
```

