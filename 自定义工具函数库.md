##### 笔记内容可以参考 wls 的 [自定义工具函数库](https://zxfjd3g.github.io/aishangwang_utils-docs/)

##### 本仓库一共有两个分支：dev 和 master

- dev分支：封装的js方法在 js 代码中简单使用
- master分支：通过webpack打包后，生成UMD形式的库，可以同时在nodejs和浏览器环境中使用，可以通过es6、commonjs、es5的方式引入使用；并且在该分支下，还对代码做了调整，使其可以发布到npm中央仓库上供所有人使用；

##### 通过webpack打包后，生成UMD形式的库

```
# webpack.config.js 文件内
// 出口
output: {
    // 向外暴露的对象的名称，打包后，引入 wls_utils.js 文件后，可以在全局直接使用 utils ，里面包含本次打包的入口文件内的导出的所有方法
    library: 'utils',
    // 打包生成umd的库，模块导入的时候可以通过esm（es6）/commonjs（common）/requirejs（amd）的语法引入该打包后的文件
    libraryTarget: 'umd',
  }
```

##### 发布到npm中央仓库

```
# package.json 文件内
name: 必须是唯一的名称(在npm在线中央仓库中没有同名的，小写)
main: 必须指定为打包生成的js文件路径
keywords: 指定一些方便别的程序员搜索到当前库的关键字（npm中可以直接搜到）
```

###### 发布之前需要对npm本地做如下配置修改

- npm配置的中央仓库不能是淘宝镜像，因为淘宝镜像是一个只读镜像，只能下载不能上传；
- 发布前必须执行: npm config set registry https://registry.npmjs.org/
- 不用发布时再改回: npm config set registry http://registry.npm.taobao.org/
- 查看配置: npm config list

###### 注册npm中央仓库账号

- 注册地址: https://www.npmjs.com/
- 关键信息: 用户名/密码/邮箱(需要验证)

###### 添加用户

- 执行: npm addUser 或者 npm login
- 登陆npm仓库
- 依次指定用户名/密码/邮箱（密码输入的时候是不可见的）

###### 发布仓库

- 执行: npm publish
- 常见的发布失败的错误

![](C:\Users\WLS\Desktop\自己练习\前端\练习\JS\tool\image\常见的发布失败的错误.png)

- 发布失败, 原因是库的名称重复了, 修改name为一个唯一值, 再发布

###### 如果以后需要更新npm中央仓代码，需要更新代码后再发布

- 修改项目库的版本号: package.json 中的version 从1.0.0 改为1.0.1, 注意一定要变大
- 修改代码后重新打包: npm run build
- 执行发布: npm publish

###### 强制删除已发布在npm中央仓的库

- 执行: npm unpublish --force  默认删除最近一次提交的版本
- 执行: npm unpublish 名字 --force  删除这个npm包
- 注意: 必须在72小时内, 否则不能再删除

##### 我的npm账号为 wls_   密码为 平常的密码，字母后面加名字缩写





-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------



### Symbol

##### Symbol 的基本使用

- ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。
- 创建 Symbol
  - 字面量 ` Symbol() ` ;
  - ` Symbol.for('wls') ` ;

```
// 方法一：
let s1 = Symbol();
let s2 = Symbol('aaa');
console.log(s1, typeof s1);

// 方法二：
let s3 = Symbol.for('wls');
let s3_2 = Symbol.for('wls');
console.log(s3 === s3_2);
```

##### Symbol 特点

- Symbol 的值是唯一的，用来解决命名冲突的问题；
- Symbol 值不能与其他数据进行运算；
- Symbol 定义 的 对象属 性 不能 使 用 ` for…in`  循 环遍 历 ，但 是可 以 使 用 ` Reflect.ownKeys ` 来获取对象的所有键名;

##### **Symbol** **内置属性**

- Symbol内置属性 是固定写法，它的整体通常作为对象的一个属性，来改变对象在特定场景下的表现，可以扩展对象的功能；

| 内置属性                  | 作用                                                         |
| ------------------------- | ------------------------------------------------------------ |
| Symbol.hasInstance        | 当其他对象使用 instanceof 运算符，判断是否为该对象的实例时，会调用这个方法 |
| Symbol.isConcatSpreadable | 对象的 Symbol.isConcatSpreadable 属性等于的是一个布尔值，表示该对象用于 Array.prototype.concat()时，是否可以展开。 |
| Symbol.species            | 创建衍生对象时，会使用该属性                                 |
| Symbol.match              | 当执行 str.match(myObject) 时，如果该属性存在，会调用它，返回该方法的返回值。 |
| Symbol.replace            | 当该对象被 str.replace(myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.search             | 当该对象被 str.search (myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.split              | 当该对象被 str.split(myObject)方法调用时，会返回该方法的返回值。 |
| Symbol.iterator           | 对象进行 for...of 循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器 |
| Symbol.toPrimitive        | 该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 |
| Symbol. toStringTag       | 在该对象上面调用 toString 方法时，返回该方法的返回值         |
| Symbol. unscopables       | 该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除。 |

##### 属性练习

###### Symbol.hasInstance 可以自己来控制类型检测

```
属性一：Symbol.hasInstance 可以自己来控制类型检测
class Person{
    static [Symbol.hasInstance](param){
        console.log(param); // {a: 1};
        console.log("我被用来检测类型了");
        return true;
    }
}
let o = {a: 1};
console.log(o instanceof Person); // true
```

###### Symbol.isConcatSpreadable 可以控制数组采用concat合并时，某个数组是否被展开后合并

```
属性二：Symbol.isConcatSpreadable 可以控制数组采用concat合并时，某个数组是否被展开后合并
const arr = [1,2,3];
const arr2 = [4,5,6];
arr2[Symbol.isConcatSpreadable] = false;
console.log(arr.concat(arr2)); // [1,2,3,[4,5,6]]
```

